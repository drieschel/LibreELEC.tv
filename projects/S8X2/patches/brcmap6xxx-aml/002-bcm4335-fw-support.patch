diff -Naur brcmap6xxx-aml-de3f5c5.orig/bcmdhd_1_201_59_x/dhd_config.c brcmap6xxx-aml-de3f5c5/bcmdhd_1_201_59_x/dhd_config.c
--- brcmap6xxx-aml-de3f5c5.orig/bcmdhd_1_201_59_x/dhd_config.c	2018-11-06 21:49:41.621431878 +0100
+++ brcmap6xxx-aml-de3f5c5/bcmdhd_1_201_59_x/dhd_config.c	2018-11-06 23:01:48.000000000 +0100
@@ -4,7 +4,7 @@
 
 #include <bcmutils.h>
 #include <hndsoc.h>
-#include <bcmsdbus.h>
+#include <bcmsdbus.h>
 #if defined(HW_OOB) || defined(FORCE_WOWLAN)
 #include <bcmdefs.h>
 #include <bcmsdh.h>
@@ -45,22 +45,22 @@
 #define FW_TYPE_MFG     3
 #define FW_TYPE_G       0
 #define FW_TYPE_AG      1
-
-#ifdef CONFIG_PATH_AUTO_SELECT
-#define BCM4330B2_CONF_NAME "config_40183b2.txt"
-#define BCM43362A0_CONF_NAME "config_40181a0.txt"
-#define BCM43362A2_CONF_NAME "config_40181a2.txt"
-#define BCM43438A0_CONF_NAME "config_43438a0.txt"
-#define BCM43438A1_CONF_NAME "config_43438a1.txt"
-#define BCM4334B1_CONF_NAME "config_4334b1.txt"
-#define BCM43341B0_CONF_NAME "config_43341b0.txt"
-#define BCM43241B4_CONF_NAME "config_43241b4.txt"
-#define BCM4339A0_CONF_NAME "config_4339a0.txt"
-#define BCM43455C0_CONF_NAME "config_43455c0.txt"
-#define BCM4354A1_CONF_NAME "config_4354a1.txt"
-#define BCM4356A2_CONF_NAME "config_4356a2.txt"
-#define BCM4359B1_CONF_NAME "config_4359b1.txt"
-#endif
+
+#ifdef CONFIG_PATH_AUTO_SELECT
+#define BCM4330B2_CONF_NAME "config_40183b2.txt"
+#define BCM43362A0_CONF_NAME "config_40181a0.txt"
+#define BCM43362A2_CONF_NAME "config_40181a2.txt"
+#define BCM43438A0_CONF_NAME "config_43438a0.txt"
+#define BCM43438A1_CONF_NAME "config_43438a1.txt"
+#define BCM4334B1_CONF_NAME "config_4334b1.txt"
+#define BCM43341B0_CONF_NAME "config_43341b0.txt"
+#define BCM43241B4_CONF_NAME "config_43241b4.txt"
+#define BCM4339A0_CONF_NAME "config_4339a0.txt"
+#define BCM43455C0_CONF_NAME "config_43455c0.txt"
+#define BCM4354A1_CONF_NAME "config_4354a1.txt"
+#define BCM4356A2_CONF_NAME "config_4356a2.txt"
+#define BCM4359B1_CONF_NAME "config_4359b1.txt"
+#endif
 
 #ifdef BCMSDIO
 #define SBSDIO_CIS_SIZE_LIMIT		0x200		/* maximum bytes in one CIS */
@@ -93,13 +93,13 @@
 	"fw_bcm40181a2_mfg.bin"
 };
 
-const static char *bcm4334b1_ag_fw_name[] = {
-	"fw_bcm4334b1_ag.bin",
-	"fw_bcm4334b1_ag_apsta.bin",
-	"fw_bcm4334b1_ag_p2p.bin",
-	"fw_bcm4334b1_ag_mfg.bin"
-};
-
+const static char *bcm4334b1_ag_fw_name[] = {
+	"fw_bcm4334b1_ag.bin",
+	"fw_bcm4334b1_ag_apsta.bin",
+	"fw_bcm4334b1_ag_p2p.bin",
+	"fw_bcm4334b1_ag_mfg.bin"
+};
+
 const static char *bcm43438a0_fw_name[] = {
 	"fw_bcm43438a0.bin",
 	"fw_bcm43438a0_apsta.bin",
@@ -128,6 +128,13 @@
 	"fw_bcm43241b4_ag_mfg.bin"
 };
 
+const static char *bcm4335b0_ag_fw_name[] = {
+	"fw_bcm4335b0_ag.bin",
+	"fw_bcm4335b0_ag_apsta.bin",
+	"fw_bcm4335b0_ag_p2p.bin",
+	"fw_bcm4335b0_ag_mfg.bin"
+};
+
 const static char *bcm4339a0_ag_fw_name[] = {
 	"fw_bcm4339a0_ag.bin",
 	"fw_bcm4339a0_ag_apsta.bin",
@@ -155,13 +162,13 @@
 	"fw_bcm4356a2_ag_p2p.bin",
 	"fw_bcm4356a2_ag_mfg.bin"
 };
-
-const static char *bcm4359b1_ag_fw_name[] = {
-	"fw_bcm4359b1_ag.bin",
-	"fw_bcm4359b1_ag_apsta.bin",
-	"fw_bcm4359b1_ag_p2p.bin",
-	"fw_bcm4359b1_ag_mfg.bin"
-};
+
+const static char *bcm4359b1_ag_fw_name[] = {
+	"fw_bcm4359b1_ag.bin",
+	"fw_bcm4359b1_ag_apsta.bin",
+	"fw_bcm4359b1_ag_p2p.bin",
+	"fw_bcm4359b1_ag_mfg.bin"
+};
 #endif
 #ifdef BCMPCIE
 const static char *bcm4356a2_pcie_ag_fw_name[] = {
@@ -211,7 +218,7 @@
 	chip_nv_list->count = 0;
 }
 
-#if defined(HW_OOB) || defined(FORCE_WOWLAN)
+#if defined(HW_OOB) || defined(FORCE_WOWLAN)
 void
 dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip)
 {
@@ -271,13 +278,13 @@
 		if (config_msg_level & CONFIG_TRACE_LEVEL) {
 			printf("%s: tpl_code=0x%02x, tpl_link=0x%02x, tag=0x%02x\n",
 				__FUNCTION__, tpl_code, tpl_link, *ptr);
-			printk("%s: value:", __FUNCTION__);
+			printk("%s: value:", __FUNCTION__);
 			for (i=0; i<tpl_link-1; i++) {
-				printk("%02x ", ptr[i+1]);
+				printk("%02x ", ptr[i+1]);
 				if ((i+1) % 16 == 0)
-					printk("\n");
+					printk("\n");
 			}
-			printk("\n");
+			printk("\n");
 		}
 
 		if (tpl_code == 0x80 && tpl_link == 0x07 && *ptr == 0x19)
@@ -485,11 +492,11 @@
 			else if (chiprev == BCM43430A1_CHIP_REV)
 				strcpy(&fw_path[i+1], bcm43438a1_fw_name[fw_type]);
 			break;
-		case BCM4334_CHIP_ID:
-			if (chiprev == BCM4334B1_CHIP_REV)
-				strcpy(&fw_path[i+1], bcm4334b1_ag_fw_name[fw_type]);
+		case BCM4334_CHIP_ID:
+			if (chiprev == BCM4334B1_CHIP_REV)
+				strcpy(&fw_path[i+1], bcm4334b1_ag_fw_name[fw_type]);
 			break;
-		case BCM43340_CHIP_ID:
+		case BCM43340_CHIP_ID:
 		case BCM43341_CHIP_ID:
 			if (chiprev == BCM43341B0_CHIP_REV)
 				strcpy(&fw_path[i+1], bcm43341b0_ag_fw_name[fw_type]);
@@ -501,9 +508,11 @@
 		case BCM4335_CHIP_ID:
 			if (chiprev == BCM4335A0_CHIP_REV)
 				strcpy(&fw_path[i+1], bcm4339a0_ag_fw_name[fw_type]);
+			else if (chiprev == BCM4335B0_CHIP_REV)
+				strcpy(&fw_path[i+1], bcm4335b0_ag_fw_name[fw_type]);
 			break;
 		case BCM4345_CHIP_ID:
-		case BCM43454_CHIP_ID:
+		case BCM43454_CHIP_ID:
 			if (chiprev == BCM43455C0_CHIP_REV)
 				strcpy(&fw_path[i+1], bcm43455c0_ag_fw_name[fw_type]);
 			break;
@@ -517,15 +526,15 @@
 			else if (chiprev == BCM4356A2_CHIP_REV)
 				strcpy(&fw_path[i+1], bcm4356a2_ag_fw_name[fw_type]);
 			break;
-		case BCM4356_CHIP_ID:
-		case BCM4371_CHIP_ID:
-			if (chiprev == BCM4356A2_CHIP_REV)
-				strcpy(&fw_path[i+1], bcm4356a2_ag_fw_name[fw_type]);
-			break;
-		case BCM4359_CHIP_ID:
-			if (chiprev == BCM4359B1_CHIP_REV)
-				strcpy(&fw_path[i+1], bcm4359b1_ag_fw_name[fw_type]);
-			break;
+		case BCM4356_CHIP_ID:
+		case BCM4371_CHIP_ID:
+			if (chiprev == BCM4356A2_CHIP_REV)
+				strcpy(&fw_path[i+1], bcm4356a2_ag_fw_name[fw_type]);
+			break;
+		case BCM4359_CHIP_ID:
+			if (chiprev == BCM4359B1_CHIP_REV)
+				strcpy(&fw_path[i+1], bcm4359b1_ag_fw_name[fw_type]);
+			break;
 #endif
 #ifdef BCMPCIE
 		case BCM4356_CHIP_ID:
@@ -609,169 +618,169 @@
 	printf("%s: config_path=%s\n", __FUNCTION__, conf_path);
 }
 
-#ifdef CONFIG_PATH_AUTO_SELECT
-void
-dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path)
-{
-	uint chip, chiprev;
-	int i;
-
-	chip = dhd->conf->chip;
-	chiprev = dhd->conf->chiprev;
-
-	if (conf_path[0] == '\0') {
-		printf("config path is null\n");
-		return;
-	}
-
-	/* find out the last '/' */
-	i = strlen(conf_path);
-	while (i > 0) {
-		if (conf_path[i] == '/') break;
-		i--;
-	}
-
-	switch (chip) {
-#ifdef BCMSDIO
-		case BCM4330_CHIP_ID:
-			if (chiprev == BCM4330B2_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4330B2_CONF_NAME);
-			break;
-		case BCM43362_CHIP_ID:
-			if (chiprev == BCM43362A0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43362A0_CONF_NAME);
-			else
-				strcpy(&conf_path[i+1], BCM43362A2_CONF_NAME);
-			break;
-		case BCM43430_CHIP_ID:
-			if (chiprev == BCM43430A0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43438A0_CONF_NAME);
-			else if (chiprev == BCM43430A1_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43438A1_CONF_NAME);
-			break;
-		case BCM4334_CHIP_ID:
-			if (chiprev == BCM4334B1_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4334B1_CONF_NAME);
-			break;
-		case BCM43340_CHIP_ID:
-		case BCM43341_CHIP_ID:
-			if (chiprev == BCM43341B0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43341B0_CONF_NAME);
-			break;
-		case BCM4324_CHIP_ID:
-			if (chiprev == BCM43241B4_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43241B4_CONF_NAME);
-			break;
-		case BCM4335_CHIP_ID:
-			if (chiprev == BCM4335A0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4339A0_CONF_NAME);
-			break;
-		case BCM4345_CHIP_ID:
-		case BCM43454_CHIP_ID:
-			if (chiprev == BCM43455C0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM43455C0_CONF_NAME);
-			break;
-		case BCM4339_CHIP_ID:
-			if (chiprev == BCM4339A0_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4339A0_CONF_NAME);
-			break;
-		case BCM4354_CHIP_ID:
-			if (chiprev == BCM4354A1_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4354A1_CONF_NAME);
-			else if (chiprev == BCM4356A2_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
-			break;
-		case BCM4356_CHIP_ID:
-		case BCM4371_CHIP_ID:
-			if (chiprev == BCM4356A2_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
-			break;
-		case BCM4359_CHIP_ID:
-			if (chiprev == BCM4359B1_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4359B1_CONF_NAME);
-			break;
-#endif
-#ifdef BCMPCIE
-		case BCM4356_CHIP_ID:
-			if (chiprev == BCM4356A2_CHIP_REV)
-				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
-			break;
-#endif
-	}
-
-	printf("%s: config_path=%s\n", __FUNCTION__, conf_path);
-}
-#endif
-
+#ifdef CONFIG_PATH_AUTO_SELECT
+void
+dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path)
+{
+	uint chip, chiprev;
+	int i;
+
+	chip = dhd->conf->chip;
+	chiprev = dhd->conf->chiprev;
+
+	if (conf_path[0] == '\0') {
+		printf("config path is null\n");
+		return;
+	}
+
+	/* find out the last '/' */
+	i = strlen(conf_path);
+	while (i > 0) {
+		if (conf_path[i] == '/') break;
+		i--;
+	}
+
+	switch (chip) {
+#ifdef BCMSDIO
+		case BCM4330_CHIP_ID:
+			if (chiprev == BCM4330B2_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4330B2_CONF_NAME);
+			break;
+		case BCM43362_CHIP_ID:
+			if (chiprev == BCM43362A0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43362A0_CONF_NAME);
+			else
+				strcpy(&conf_path[i+1], BCM43362A2_CONF_NAME);
+			break;
+		case BCM43430_CHIP_ID:
+			if (chiprev == BCM43430A0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43438A0_CONF_NAME);
+			else if (chiprev == BCM43430A1_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43438A1_CONF_NAME);
+			break;
+		case BCM4334_CHIP_ID:
+			if (chiprev == BCM4334B1_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4334B1_CONF_NAME);
+			break;
+		case BCM43340_CHIP_ID:
+		case BCM43341_CHIP_ID:
+			if (chiprev == BCM43341B0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43341B0_CONF_NAME);
+			break;
+		case BCM4324_CHIP_ID:
+			if (chiprev == BCM43241B4_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43241B4_CONF_NAME);
+			break;
+		case BCM4335_CHIP_ID:
+			if (chiprev == BCM4335A0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4339A0_CONF_NAME);
+			break;
+		case BCM4345_CHIP_ID:
+		case BCM43454_CHIP_ID:
+			if (chiprev == BCM43455C0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM43455C0_CONF_NAME);
+			break;
+		case BCM4339_CHIP_ID:
+			if (chiprev == BCM4339A0_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4339A0_CONF_NAME);
+			break;
+		case BCM4354_CHIP_ID:
+			if (chiprev == BCM4354A1_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4354A1_CONF_NAME);
+			else if (chiprev == BCM4356A2_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
+			break;
+		case BCM4356_CHIP_ID:
+		case BCM4371_CHIP_ID:
+			if (chiprev == BCM4356A2_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
+			break;
+		case BCM4359_CHIP_ID:
+			if (chiprev == BCM4359B1_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4359B1_CONF_NAME);
+			break;
+#endif
+#ifdef BCMPCIE
+		case BCM4356_CHIP_ID:
+			if (chiprev == BCM4356A2_CHIP_REV)
+				strcpy(&conf_path[i+1], BCM4356A2_CONF_NAME);
+			break;
+#endif
+	}
+
+	printf("%s: config_path=%s\n", __FUNCTION__, conf_path);
+}
+#endif
+
+int
+dhd_conf_set_fw_int_cmd(dhd_pub_t *dhd, char *name, uint cmd, int val,
+	int def, bool down)
+{
+	int bcmerror = -1;
+
+	if (val >= def) {
+		if (down) {
+			if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
+				CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
+		}
+		printf("%s: set %s %d %d\n", __FUNCTION__, name, cmd, val);
+		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, cmd, &val, sizeof(val), TRUE, 0)) < 0)
+			CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, name, bcmerror));
+	}
+	return bcmerror;
+}
+
 int
-dhd_conf_set_fw_int_cmd(dhd_pub_t *dhd, char *name, uint cmd, int val,
-	int def, bool down)
+dhd_conf_set_fw_int_struct_cmd(dhd_pub_t *dhd, char *name, uint cmd,
+	int *val, int len, bool down)
 {
 	int bcmerror = -1;
 
-	if (val >= def) {
-		if (down) {
-			if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
-				CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
-		}
-		printf("%s: set %s %d %d\n", __FUNCTION__, name, cmd, val);
-		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, cmd, &val, sizeof(val), TRUE, 0)) < 0)
-			CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, name, bcmerror));
-	}
-	return bcmerror;
-}
-
-int
-dhd_conf_set_fw_int_struct_cmd(dhd_pub_t *dhd, char *name, uint cmd,
-	int *val, int len, bool down)
-{
-	int bcmerror = -1;
-
-	if (down) {
-		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
-			CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
-	}
-	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, cmd, val, len, TRUE, 0)) < 0)
-		CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, name, bcmerror));
-
-	return bcmerror;
-}
-
-int
-dhd_conf_set_fw_string_cmd(dhd_pub_t *dhd, char *cmd, int val, int def,
-	bool down)
-{
-	int bcmerror = -1;
-	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
-
-	if (val >= def) {
-		if (down) {
-			if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
-				CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
-		}
-		printf("%s: set %s %d\n", __FUNCTION__, cmd, val);
-		bcm_mkiovar(cmd, (char *)&val, 4, iovbuf, sizeof(iovbuf));
-		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
-			CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, cmd, bcmerror));
-	}
-	return bcmerror;
-}
-
-int
-dhd_conf_set_fw_string_struct_cmd(dhd_pub_t *dhd, char *cmd, char *val,
-	int len, bool down)
-{
-	int bcmerror = -1;
-	char iovbuf[WLC_IOCTL_SMLEN];
-	
-	if (down) {
-		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
-			CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
-	}
-	printf("%s: set %s\n", __FUNCTION__, cmd);
-	bcm_mkiovar(cmd, val, len, iovbuf, sizeof(iovbuf));
-	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
-		CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, cmd, bcmerror));
+	if (down) {
+		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
+			CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
+	}
+	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, cmd, val, len, TRUE, 0)) < 0)
+		CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, name, bcmerror));
+
+	return bcmerror;
+}
+
+int
+dhd_conf_set_fw_string_cmd(dhd_pub_t *dhd, char *cmd, int val, int def,
+	bool down)
+{
+	int bcmerror = -1;
+	char iovbuf[WL_EVENTING_MASK_LEN + 12];	/*  Room for "event_msgs" + '\0' + bitvec  */
+
+	if (val >= def) {
+		if (down) {
+			if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
+				CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
+		}
+		printf("%s: set %s %d\n", __FUNCTION__, cmd, val);
+		bcm_mkiovar(cmd, (char *)&val, 4, iovbuf, sizeof(iovbuf));
+		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+			CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, cmd, bcmerror));
+	}
+	return bcmerror;
+}
+
+int
+dhd_conf_set_fw_string_struct_cmd(dhd_pub_t *dhd, char *cmd, char *val,
+	int len, bool down)
+{
+	int bcmerror = -1;
+	char iovbuf[WLC_IOCTL_SMLEN];
+	
+	if (down) {
+		if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_DOWN, NULL, 0, TRUE, 0)) < 0)
+			CONFIG_ERROR(("%s: WLC_DOWN setting failed %d\n", __FUNCTION__, bcmerror));
+	}
+	printf("%s: set %s\n", __FUNCTION__, cmd);
+	bcm_mkiovar(cmd, val, len, iovbuf, sizeof(iovbuf));
+	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0)) < 0)
+		CONFIG_ERROR(("%s: %s setting failed %d\n", __FUNCTION__, cmd, bcmerror));
 
 	return bcmerror;
 }
@@ -795,9 +804,9 @@
 	int bcmerror = -1;
 
 	memset(&dhd->dhd_cspec, 0, sizeof(wl_country_t));
-	printf("%s: set country %s, revision %d\n", __FUNCTION__,
+	printf("%s: set country %s, revision %d\n", __FUNCTION__,
 		dhd->conf->cspec.ccode, dhd->conf->cspec.rev);
-	dhd_conf_set_fw_string_struct_cmd(dhd, "country", (char *)&dhd->conf->cspec, sizeof(wl_country_t), FALSE);
+	dhd_conf_set_fw_string_struct_cmd(dhd, "country", (char *)&dhd->conf->cspec, sizeof(wl_country_t), FALSE);
 
 	return bcmerror;
 }
@@ -810,28 +819,28 @@
 	memset(cspec, 0, sizeof(wl_country_t));
 	bcm_mkiovar("country", NULL, 0, (char*)cspec, sizeof(wl_country_t));
 	if ((bcmerror = dhd_wl_ioctl_cmd(dhd, WLC_GET_VAR, cspec, sizeof(wl_country_t), FALSE, 0)) < 0)
-		CONFIG_ERROR(("%s: country code getting failed %d\n", __FUNCTION__, bcmerror));
+		CONFIG_ERROR(("%s: country code getting failed %d\n", __FUNCTION__, bcmerror));
 	else
 		printf("Country code: %s (%s/%d)\n", cspec->country_abbrev, cspec->ccode, cspec->rev);
-
-	return bcmerror;
-}
-
-int
-dhd_conf_get_country_from_config(dhd_pub_t *dhd, wl_country_t *cspec)
-{
-	int bcmerror = -1, i;
-	struct dhd_conf *conf = dhd->conf;
-
-	for (i = 0; i < conf->country_list.count; i++) {
-		if (strcmp(cspec->country_abbrev, conf->country_list.cspec[i].country_abbrev) == 0) {
-			memcpy(cspec->ccode,
-				conf->country_list.cspec[i].ccode, WLC_CNTRY_BUF_SZ);
-			cspec->rev = conf->country_list.cspec[i].rev;
-			printf("%s: %s/%d\n", __FUNCTION__, cspec->ccode, cspec->rev);
-			return 0;
-		}
-	}
+
+	return bcmerror;
+}
+
+int
+dhd_conf_get_country_from_config(dhd_pub_t *dhd, wl_country_t *cspec)
+{
+	int bcmerror = -1, i;
+	struct dhd_conf *conf = dhd->conf;
+
+	for (i = 0; i < conf->country_list.count; i++) {
+		if (strcmp(cspec->country_abbrev, conf->country_list.cspec[i].country_abbrev) == 0) {
+			memcpy(cspec->ccode,
+				conf->country_list.cspec[i].ccode, WLC_CNTRY_BUF_SZ);
+			cspec->rev = conf->country_list.cspec[i].rev;
+			printf("%s: %s/%d\n", __FUNCTION__, cspec->ccode, cspec->rev);
+			return 0;
+		}
+	}
 
 	return bcmerror;
 }
@@ -900,22 +909,22 @@
 	struct dhd_conf *conf = dhd->conf;
 
 	dhd_roam_disable = conf->roam_off;
-	dhd_conf_set_fw_string_cmd(dhd, "roam_off", dhd->conf->roam_off, 0, FALSE);
+	dhd_conf_set_fw_string_cmd(dhd, "roam_off", dhd->conf->roam_off, 0, FALSE);
 
 	if (!conf->roam_off || !conf->roam_off_suspend) {
-		printf("%s: set roam_trigger %d\n", __FUNCTION__, conf->roam_trigger[0]);
-		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_TRIGGER", WLC_SET_ROAM_TRIGGER,
-				conf->roam_trigger, sizeof(conf->roam_trigger), FALSE);
-
-		printf("%s: set roam_scan_period %d\n", __FUNCTION__, conf->roam_scan_period[0]);
-		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_SCAN_PERIOD", WLC_SET_ROAM_SCAN_PERIOD,
-				conf->roam_scan_period, sizeof(conf->roam_scan_period), FALSE);
-
-		printf("%s: set roam_delta %d\n", __FUNCTION__, conf->roam_delta[0]);
-		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_DELTA", WLC_SET_ROAM_DELTA,
-				conf->roam_delta, sizeof(conf->roam_delta), FALSE);
-		
-		dhd_conf_set_fw_string_cmd(dhd, "fullroamperiod", dhd->conf->fullroamperiod, 1, FALSE);
+		printf("%s: set roam_trigger %d\n", __FUNCTION__, conf->roam_trigger[0]);
+		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_TRIGGER", WLC_SET_ROAM_TRIGGER,
+				conf->roam_trigger, sizeof(conf->roam_trigger), FALSE);
+
+		printf("%s: set roam_scan_period %d\n", __FUNCTION__, conf->roam_scan_period[0]);
+		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_SCAN_PERIOD", WLC_SET_ROAM_SCAN_PERIOD,
+				conf->roam_scan_period, sizeof(conf->roam_scan_period), FALSE);
+
+		printf("%s: set roam_delta %d\n", __FUNCTION__, conf->roam_delta[0]);
+		dhd_conf_set_fw_int_struct_cmd(dhd, "WLC_SET_ROAM_DELTA", WLC_SET_ROAM_DELTA,
+				conf->roam_delta, sizeof(conf->roam_delta), FALSE);
+		
+		dhd_conf_set_fw_string_cmd(dhd, "fullroamperiod", dhd->conf->fullroamperiod, 1, FALSE);
 	}
 
 	return bcmerror;
@@ -1001,8 +1010,8 @@
 	* Put WME acparams after "wme_ac\0" in buf.
 	* NOTE: only one of the four ACs can be set at a time.
 	*/
-	dhd_conf_set_fw_string_struct_cmd(dhd, "wme_ac_sta", (char *)acp, sizeof(edcf_acparam_t), FALSE);
-
+	dhd_conf_set_fw_string_struct_cmd(dhd, "wme_ac_sta", (char *)acp, sizeof(edcf_acparam_t), FALSE);
+
 }
 
 void
@@ -1039,30 +1048,30 @@
 dhd_conf_add_pkt_filter(dhd_pub_t *dhd)
 {
 	int i;
-	char str[12];
-#define MACS "%02x%02x%02x%02x%02x%02x"
+	char str[12];
+#define MACS "%02x%02x%02x%02x%02x%02x"
 
 	/*
-	 * All pkt: pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
-	 * Netbios pkt: 120 0 0 12 0xFFFF000000000000000000FF000000000000000000000000FFFF 0x0800000000000000000000110000000000000000000000000089
-	 */
-	for(i=0; i<dhd->conf->pkt_filter_add.count; i++) {
+	 * All pkt: pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
+	 * Netbios pkt: 120 0 0 12 0xFFFF000000000000000000FF000000000000000000000000FFFF 0x0800000000000000000000110000000000000000000000000089
+	 */
+	for(i=0; i<dhd->conf->pkt_filter_add.count; i++) {
 		dhd->pktfilter[i+dhd->pktfilter_count] = dhd->conf->pkt_filter_add.filter[i];
 		printf("%s: %s\n", __FUNCTION__, dhd->pktfilter[i+dhd->pktfilter_count]);
 	}
 	dhd->pktfilter_count += i;
-
-	if (dhd->conf->pkt_filter_magic) {
-		strcpy(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], "256 0 1 0 0x");
-		for (i=0; i<16; i++)
-			strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], "FFFFFFFFFFFF");
-		strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], " 0x");
-		sprintf(str, MACS, MAC2STRDBG(dhd->mac.octet));
-		for (i=0; i<16; i++)
-			strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], str);
-		dhd->pktfilter[dhd->pktfilter_count] = dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count];
-		dhd->pktfilter_count += 1;
-	}
+
+	if (dhd->conf->pkt_filter_magic) {
+		strcpy(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], "256 0 1 0 0x");
+		for (i=0; i<16; i++)
+			strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], "FFFFFFFFFFFF");
+		strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], " 0x");
+		sprintf(str, MACS, MAC2STRDBG(dhd->mac.octet));
+		for (i=0; i<16; i++)
+			strcat(&dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count][0], str);
+		dhd->pktfilter[dhd->pktfilter_count] = dhd->conf->pkt_filter_add.filter[dhd->conf->pkt_filter_add.count];
+		dhd->pktfilter_count += 1;
+	}
 }
 
 bool
@@ -1117,21 +1126,21 @@
 }
 
 int
-dhd_conf_get_pm(dhd_pub_t *dhd)
+dhd_conf_get_pm(dhd_pub_t *dhd)
 {
 	if (dhd && dhd->conf)
 		return dhd->conf->pm;
 	return -1;
 }
 
-int
-dhd_conf_get_tcpack_sup_mode(dhd_pub_t *dhd)
-{
-	if (dhd && dhd->conf)
-		return dhd->conf->tcpack_sup_mode;
-	return -1;
-}
-
+int
+dhd_conf_get_tcpack_sup_mode(dhd_pub_t *dhd)
+{
+	if (dhd && dhd->conf)
+		return dhd->conf->tcpack_sup_mode;
+	return -1;
+}
+
 unsigned int
 process_config_vars(char *varbuf, unsigned int len, char *pickbuf, char *param)
 {
@@ -1194,14 +1203,14 @@
 dhd_conf_read_log_level(dhd_pub_t *dhd, char *bufp, uint len)
 {
 	uint len_val;
-	char *pick;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
+	char *pick;
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
 
 	/* Process dhd_msglevel */
 	memset(pick, 0, MAXSZ_BUF);
@@ -1252,7 +1261,7 @@
 	}
 #endif
 
-#if defined(DHD_DEBUG)
+#if defined(DHD_DEBUG)
 	/* Process dhd_console_ms */
 	memset(pick, 0, MAXSZ_BUF);
 	len_val = process_config_vars(bufp, len, pick, "dhd_console_ms=");
@@ -1260,25 +1269,25 @@
 		dhd_console_ms = (int)simple_strtol(pick, NULL, 0);
 		printf("%s: dhd_console_ms = 0x%X\n", __FUNCTION__, dhd_console_ms);
 	}
-#endif
-
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
+#endif
+
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
 }
 
 void
 dhd_conf_read_wme_ac_params(dhd_pub_t *dhd, char *bufp, uint len)
 {
 	uint len_val;
-	char *pick;
+	char *pick;
 	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
 
 	/* Process WMM parameters */
 	memset(pick, 0, MAXSZ_BUF);
@@ -1374,213 +1383,213 @@
 		}
 	}
 
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-
-}
-
-void
-dhd_conf_read_fw_by_mac(dhd_pub_t *dhd, char *bufp, uint len)
-{
-	uint len_val;
-	int i, j;
-	char *pick;
-	char *pch, *pick_tmp;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
-
-	/* Process fw_by_mac:
-	 * fw_by_mac=[fw_mac_num] \
-	 *  [fw_name1] [mac_num1] [oui1-1] [nic_start1-1] [nic_end1-1] \
-	 *                                    [oui1-1] [nic_start1-1] [nic_end1-1]... \
-	 *                                    [oui1-n] [nic_start1-n] [nic_end1-n] \
-	 *  [fw_name2] [mac_num2] [oui2-1] [nic_start2-1] [nic_end2-1] \
-	 *                                    [oui2-1] [nic_start2-1] [nic_end2-1]... \
-	 *                                    [oui2-n] [nic_start2-n] [nic_end2-n] \
-	 * Ex: fw_by_mac=2 \
-	 *  fw_bcmdhd1.bin 2 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
-	 *  fw_bcmdhd2.bin 3 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
-	 *                           0x983B16 0x916157 0x916487
-	 */
-	memset(pick, 0, MAXSZ_BUF);
-	len_val = process_config_vars(bufp, len, pick, "fw_by_mac=");
-	if (len_val) {
-		pick_tmp = pick;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->fw_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->fw_by_mac.count, GFP_KERNEL))) {
-			conf->fw_by_mac.count = 0;
-			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-		}
-		printf("%s: fw_count=%d\n", __FUNCTION__, conf->fw_by_mac.count);
-		conf->fw_by_mac.m_mac_list_head = mac_list;
-		for (i=0; i<conf->fw_by_mac.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(mac_list[i].name, pch);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
-			printf("%s: name=%s, mac_count=%d\n", __FUNCTION__,
-				mac_list[i].name, mac_list[i].count);
-			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count, GFP_KERNEL))) {
-				mac_list[i].count = 0;
-				CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-				break;
-			}
-			mac_list[i].mac = mac_range;
-			for (j=0; j<mac_list[i].count; j++) {
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
-				printf("%s: oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
-					__FUNCTION__, mac_range[j].oui,
-					mac_range[j].nic_start, mac_range[j].nic_end);
-			}
-		}
-	}
-
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-}
-
-void
-dhd_conf_read_nv_by_mac(dhd_pub_t *dhd, char *bufp, uint len)
-{
-	uint len_val;
-	int i, j;
-	char *pick;
-	char *pch, *pick_tmp;
-	wl_mac_list_t *mac_list;
-	wl_mac_range_t *mac_range;
-	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
-
-	/* Process nv_by_mac:
-	 * [nv_by_mac]: The same format as fw_by_mac
-	 */
-	memset(pick, 0, MAXSZ_BUF);
-	len_val = process_config_vars(bufp, len, pick, "nv_by_mac=");
-	if (len_val) {
-		pick_tmp = pick;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->nv_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_mac.count, GFP_KERNEL))) {
-			conf->nv_by_mac.count = 0;
-			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-		}
-		printf("%s: nv_count=%d\n", __FUNCTION__, conf->nv_by_mac.count);
-		conf->nv_by_mac.m_mac_list_head = mac_list;
-		for (i=0; i<conf->nv_by_mac.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(mac_list[i].name, pch);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
-			printf("%s: name=%s, mac_count=%d\n", __FUNCTION__,
-				mac_list[i].name, mac_list[i].count);
-			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count, GFP_KERNEL))) {
-				mac_list[i].count = 0;
-				CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-				break;
-			}
-			mac_list[i].mac = mac_range;
-			for (j=0; j<mac_list[i].count; j++) {
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
-				pch = bcmstrtok(&pick_tmp, " ", 0);
-				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
-				printf("%s: oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
-					__FUNCTION__, mac_range[j].oui,
-					mac_range[j].nic_start, mac_range[j].nic_end);
-			}
-		}
-	}
-
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-}
-
-void
-dhd_conf_read_nv_by_chip(dhd_pub_t *dhd, char *bufp, uint len)
-{
-	uint len_val;
-	int i;
-	char *pick;
-	char *pch, *pick_tmp;
-	wl_chip_nv_path_t *chip_nv_path;
-	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
-
-	/* Process nv_by_chip:
-	 * nv_by_chip=[nv_chip_num] \
-	 *  [chip1] [chiprev1] [nv_name1] [chip2] [chiprev2] [nv_name2] \
-	 * Ex: nv_by_chip=2 \
-	 *  43430 0 nvram_ap6212.txt 43430 1 nvram_ap6212a.txt \
-	 */
-	memset(pick, 0, MAXSZ_BUF);
-	len_val = process_config_vars(bufp, len, pick, "nv_by_chip=");
-	if (len_val) {
-		pick_tmp = pick;
-		pch = bcmstrtok(&pick_tmp, " ", 0);
-		conf->nv_by_chip.count = (uint32)simple_strtol(pch, NULL, 0);
-		if (!(chip_nv_path = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_chip.count, GFP_KERNEL))) {
-			conf->nv_by_chip.count = 0;
-			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
-		}
-		printf("%s: nv_by_chip_count=%d\n", __FUNCTION__, conf->nv_by_chip.count);
-		conf->nv_by_chip.m_chip_nv_path_head = chip_nv_path;
-		for (i=0; i<conf->nv_by_chip.count; i++) {
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			chip_nv_path[i].chip = (uint32)simple_strtol(pch, NULL, 0);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			chip_nv_path[i].chiprev = (uint32)simple_strtol(pch, NULL, 0);
-			pch = bcmstrtok(&pick_tmp, " ", 0);
-			strcpy(chip_nv_path[i].name, pch);
-			printf("%s: chip=0x%x, chiprev=%d, name=%s\n", __FUNCTION__,
-				chip_nv_path[i].chip, chip_nv_path[i].chiprev, chip_nv_path[i].name);
-		}
-	}
-
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-}
-
-void
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+
+}
+
+void
+dhd_conf_read_fw_by_mac(dhd_pub_t *dhd, char *bufp, uint len)
+{
+	uint len_val;
+	int i, j;
+	char *pick;
+	char *pch, *pick_tmp;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	struct dhd_conf *conf = dhd->conf;
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
+
+	/* Process fw_by_mac:
+	 * fw_by_mac=[fw_mac_num] \
+	 *  [fw_name1] [mac_num1] [oui1-1] [nic_start1-1] [nic_end1-1] \
+	 *                                    [oui1-1] [nic_start1-1] [nic_end1-1]... \
+	 *                                    [oui1-n] [nic_start1-n] [nic_end1-n] \
+	 *  [fw_name2] [mac_num2] [oui2-1] [nic_start2-1] [nic_end2-1] \
+	 *                                    [oui2-1] [nic_start2-1] [nic_end2-1]... \
+	 *                                    [oui2-n] [nic_start2-n] [nic_end2-n] \
+	 * Ex: fw_by_mac=2 \
+	 *  fw_bcmdhd1.bin 2 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
+	 *  fw_bcmdhd2.bin 3 0x0022F4 0xE85408 0xE8549D 0x983B16 0x3557A9 0x35582A \
+	 *                           0x983B16 0x916157 0x916487
+	 */
+	memset(pick, 0, MAXSZ_BUF);
+	len_val = process_config_vars(bufp, len, pick, "fw_by_mac=");
+	if (len_val) {
+		pick_tmp = pick;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->fw_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->fw_by_mac.count, GFP_KERNEL))) {
+			conf->fw_by_mac.count = 0;
+			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+		}
+		printf("%s: fw_count=%d\n", __FUNCTION__, conf->fw_by_mac.count);
+		conf->fw_by_mac.m_mac_list_head = mac_list;
+		for (i=0; i<conf->fw_by_mac.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(mac_list[i].name, pch);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
+			printf("%s: name=%s, mac_count=%d\n", __FUNCTION__,
+				mac_list[i].name, mac_list[i].count);
+			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count, GFP_KERNEL))) {
+				mac_list[i].count = 0;
+				CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+				break;
+			}
+			mac_list[i].mac = mac_range;
+			for (j=0; j<mac_list[i].count; j++) {
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
+				printf("%s: oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
+					__FUNCTION__, mac_range[j].oui,
+					mac_range[j].nic_start, mac_range[j].nic_end);
+			}
+		}
+	}
+
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+}
+
+void
+dhd_conf_read_nv_by_mac(dhd_pub_t *dhd, char *bufp, uint len)
+{
+	uint len_val;
+	int i, j;
+	char *pick;
+	char *pch, *pick_tmp;
+	wl_mac_list_t *mac_list;
+	wl_mac_range_t *mac_range;
+	struct dhd_conf *conf = dhd->conf;
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
+
+	/* Process nv_by_mac:
+	 * [nv_by_mac]: The same format as fw_by_mac
+	 */
+	memset(pick, 0, MAXSZ_BUF);
+	len_val = process_config_vars(bufp, len, pick, "nv_by_mac=");
+	if (len_val) {
+		pick_tmp = pick;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->nv_by_mac.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(mac_list = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_mac.count, GFP_KERNEL))) {
+			conf->nv_by_mac.count = 0;
+			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+		}
+		printf("%s: nv_count=%d\n", __FUNCTION__, conf->nv_by_mac.count);
+		conf->nv_by_mac.m_mac_list_head = mac_list;
+		for (i=0; i<conf->nv_by_mac.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(mac_list[i].name, pch);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			mac_list[i].count = (uint32)simple_strtol(pch, NULL, 0);
+			printf("%s: name=%s, mac_count=%d\n", __FUNCTION__,
+				mac_list[i].name, mac_list[i].count);
+			if (!(mac_range = kmalloc(sizeof(wl_mac_range_t)*mac_list[i].count, GFP_KERNEL))) {
+				mac_list[i].count = 0;
+				CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+				break;
+			}
+			mac_list[i].mac = mac_range;
+			for (j=0; j<mac_list[i].count; j++) {
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].oui = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_start = (uint32)simple_strtol(pch, NULL, 0);
+				pch = bcmstrtok(&pick_tmp, " ", 0);
+				mac_range[j].nic_end = (uint32)simple_strtol(pch, NULL, 0);
+				printf("%s: oui=0x%06X, nic_start=0x%06X, nic_end=0x%06X\n",
+					__FUNCTION__, mac_range[j].oui,
+					mac_range[j].nic_start, mac_range[j].nic_end);
+			}
+		}
+	}
+
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+}
+
+void
+dhd_conf_read_nv_by_chip(dhd_pub_t *dhd, char *bufp, uint len)
+{
+	uint len_val;
+	int i;
+	char *pick;
+	char *pch, *pick_tmp;
+	wl_chip_nv_path_t *chip_nv_path;
+	struct dhd_conf *conf = dhd->conf;
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
+
+	/* Process nv_by_chip:
+	 * nv_by_chip=[nv_chip_num] \
+	 *  [chip1] [chiprev1] [nv_name1] [chip2] [chiprev2] [nv_name2] \
+	 * Ex: nv_by_chip=2 \
+	 *  43430 0 nvram_ap6212.txt 43430 1 nvram_ap6212a.txt \
+	 */
+	memset(pick, 0, MAXSZ_BUF);
+	len_val = process_config_vars(bufp, len, pick, "nv_by_chip=");
+	if (len_val) {
+		pick_tmp = pick;
+		pch = bcmstrtok(&pick_tmp, " ", 0);
+		conf->nv_by_chip.count = (uint32)simple_strtol(pch, NULL, 0);
+		if (!(chip_nv_path = kmalloc(sizeof(wl_mac_list_t)*conf->nv_by_chip.count, GFP_KERNEL))) {
+			conf->nv_by_chip.count = 0;
+			CONFIG_ERROR(("%s: kmalloc failed\n", __FUNCTION__));
+		}
+		printf("%s: nv_by_chip_count=%d\n", __FUNCTION__, conf->nv_by_chip.count);
+		conf->nv_by_chip.m_chip_nv_path_head = chip_nv_path;
+		for (i=0; i<conf->nv_by_chip.count; i++) {
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			chip_nv_path[i].chip = (uint32)simple_strtol(pch, NULL, 0);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			chip_nv_path[i].chiprev = (uint32)simple_strtol(pch, NULL, 0);
+			pch = bcmstrtok(&pick_tmp, " ", 0);
+			strcpy(chip_nv_path[i].name, pch);
+			printf("%s: chip=0x%x, chiprev=%d, name=%s\n", __FUNCTION__,
+				chip_nv_path[i].chip, chip_nv_path[i].chiprev, chip_nv_path[i].name);
+		}
+	}
+
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+}
+
+void
 dhd_conf_read_roam_params(dhd_pub_t *dhd, char *bufp, uint len)
 {
 	uint len_val;
-	char *pick;
+	char *pick;
 	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
 
 	/* Process roam */
 	memset(pick, 0, MAXSZ_BUF);
@@ -1633,83 +1642,83 @@
 			conf->fullroamperiod);
 	}
 
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-
-}
-
-void
-dhd_conf_read_country_list(dhd_pub_t *dhd, char *bufp, uint len)
-{
-	uint len_val;
-	int i;
-	char *pick, *pch, *pick_tmp;
-	struct dhd_conf *conf = dhd->conf;
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
-		return;
-	}
-
-	/* Process country_list:
-	 * country_list=[country1]:[ccode1]/[regrev1],
-	 * [country2]:[ccode2]/[regrev2] \
-	 * Ex: country_list=US:US/0, TW:TW/1
-	 */
-	memset(pick, 0, MAXSZ_BUF);
-	len_val = process_config_vars(bufp, len, pick, "country_list=");
-	if (len_val) {
-		pick_tmp = pick;
-		for (i=0; i<CONFIG_COUNTRY_LIST_SIZE; i++) {
-			/* Process country code */
-			pch = bcmstrtok(&pick_tmp, ":", 0);
-			if (!pch)
-				break;
-			strcpy(conf->country_list.cspec[i].country_abbrev, pch);
-			pch = bcmstrtok(&pick_tmp, "/", 0);
-			if (!pch)
-				break;
-			memcpy(conf->country_list.cspec[i].ccode, pch, 2);
-			pch = bcmstrtok(&pick_tmp, ", ", 0);
-			if (!pch)
-				break;
-			conf->country_list.cspec[i].rev = (int32)simple_strtol(pch, NULL, 10);
-			conf->country_list.count ++;
-			CONFIG_TRACE(("%s: country_list abbrev=%s, ccode=%s, regrev=%d\n", __FUNCTION__,
-				conf->country_list.cspec[i].country_abbrev,
-				conf->country_list.cspec[i].ccode,
-				conf->country_list.cspec[i].rev));
-		}
-		printf("%s: %d country in list\n", __FUNCTION__, conf->country_list.count);
-	}
-
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+
+}
+
+void
+dhd_conf_read_country_list(dhd_pub_t *dhd, char *bufp, uint len)
+{
+	uint len_val;
+	int i;
+	char *pick, *pch, *pick_tmp;
+	struct dhd_conf *conf = dhd->conf;
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
+		return;
+	}
+
+	/* Process country_list:
+	 * country_list=[country1]:[ccode1]/[regrev1],
+	 * [country2]:[ccode2]/[regrev2] \
+	 * Ex: country_list=US:US/0, TW:TW/1
+	 */
+	memset(pick, 0, MAXSZ_BUF);
+	len_val = process_config_vars(bufp, len, pick, "country_list=");
+	if (len_val) {
+		pick_tmp = pick;
+		for (i=0; i<CONFIG_COUNTRY_LIST_SIZE; i++) {
+			/* Process country code */
+			pch = bcmstrtok(&pick_tmp, ":", 0);
+			if (!pch)
+				break;
+			strcpy(conf->country_list.cspec[i].country_abbrev, pch);
+			pch = bcmstrtok(&pick_tmp, "/", 0);
+			if (!pch)
+				break;
+			memcpy(conf->country_list.cspec[i].ccode, pch, 2);
+			pch = bcmstrtok(&pick_tmp, ", ", 0);
+			if (!pch)
+				break;
+			conf->country_list.cspec[i].rev = (int32)simple_strtol(pch, NULL, 10);
+			conf->country_list.count ++;
+			CONFIG_TRACE(("%s: country_list abbrev=%s, ccode=%s, regrev=%d\n", __FUNCTION__,
+				conf->country_list.cspec[i].country_abbrev,
+				conf->country_list.cspec[i].ccode,
+				conf->country_list.cspec[i].rev));
+		}
+		printf("%s: %d country in list\n", __FUNCTION__, conf->country_list.count);
+	}
+
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
 }
 
 int
 dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path)
 {
-	int bcmerror = -1, i;
+	int bcmerror = -1, i;
 	uint len, len_val;
 	void * image = NULL;
 	char * memblock = NULL;
-	char *bufp, *pick = NULL, *pch, *pick_tmp;
+	char *bufp, *pick = NULL, *pch, *pick_tmp;
 	bool conf_file_exists;
 	struct dhd_conf *conf = dhd->conf;
 
 	conf_file_exists = ((conf_path != NULL) && (conf_path[0] != '\0'));
 	if (!conf_file_exists) {
-		printf("%s: config path %s\n", __FUNCTION__, conf_path);
-		return (0);
+		printf("%s: config path %s\n", __FUNCTION__, conf_path);
+		return (0);
 	}
 
 	if (conf_file_exists) {
 		image = dhd_os_open_image(conf_path);
 		if (image == NULL) {
-			printf("%s: Ignore config file %s\n", __FUNCTION__, conf_path);
+			printf("%s: Ignore config file %s\n", __FUNCTION__, conf_path);
 			goto err;
 		}
 	}
@@ -1718,13 +1727,13 @@
 	if (memblock == NULL) {
 		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
 			__FUNCTION__, MAXSZ_CONFIG));
-		goto err;
-	}
-
-	pick = MALLOC(dhd->osh, MAXSZ_BUF);
-	if (!pick) {
-		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
-			__FUNCTION__, MAXSZ_BUF));
+		goto err;
+	}
+
+	pick = MALLOC(dhd->osh, MAXSZ_BUF);
+	if (!pick) {
+		CONFIG_ERROR(("%s: Failed to allocate memory %d bytes\n",
+			__FUNCTION__, MAXSZ_BUF));
 		goto err;
 	}
 
@@ -1740,14 +1749,14 @@
 		dhd_conf_read_log_level(dhd, bufp, len);
 		dhd_conf_read_roam_params(dhd, bufp, len);
 		dhd_conf_read_wme_ac_params(dhd, bufp, len);
-		dhd_conf_read_fw_by_mac(dhd, bufp, len);
-		dhd_conf_read_nv_by_mac(dhd, bufp, len);
-		dhd_conf_read_nv_by_chip(dhd, bufp, len);
-		dhd_conf_read_country_list(dhd, bufp, len);
-
-		/* Process band:
-		 * band=a for 5GHz only and band=b for 2.4GHz only
-		 */
+		dhd_conf_read_fw_by_mac(dhd, bufp, len);
+		dhd_conf_read_nv_by_mac(dhd, bufp, len);
+		dhd_conf_read_nv_by_chip(dhd, bufp, len);
+		dhd_conf_read_country_list(dhd, bufp, len);
+
+		/* Process band:
+		 * band=a for 5GHz only and band=b for 2.4GHz only
+		 */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "band=");
 		if (len_val) {
@@ -1760,7 +1769,7 @@
 			printf("%s: band = %d\n", __FUNCTION__, conf->band);
 		}
 
-		/* Process mimo_bw_cap */
+		/* Process mimo_bw_cap */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "mimo_bw_cap=");
 		if (len_val) {
@@ -1804,7 +1813,7 @@
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "keep_alive_period=");
 		if (len_val) {
-			conf->keep_alive_period = (uint)simple_strtol(pick, NULL, 10);
+			conf->keep_alive_period = (uint)simple_strtol(pick, NULL, 10);
 			printf("%s: keep_alive_period = %d\n", __FUNCTION__,
 				conf->keep_alive_period);
 		}
@@ -1835,17 +1844,17 @@
 			else
 				dhd_doflow = TRUE;
 			printf("%s: dhd_doflow = %d\n", __FUNCTION__, dhd_doflow);
-		}
-
-		/* Process dhd_slpauto parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "dhd_slpauto=");
-		if (len_val) {
-			if (!strncmp(pick, "0", len_val))
-				dhd_slpauto = FALSE;
-			else
-				dhd_slpauto = TRUE;
-			printf("%s: dhd_slpauto = %d\n", __FUNCTION__, dhd_slpauto);
+		}
+
+		/* Process dhd_slpauto parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "dhd_slpauto=");
+		if (len_val) {
+			if (!strncmp(pick, "0", len_val))
+				dhd_slpauto = FALSE;
+			else
+				dhd_slpauto = TRUE;
+			printf("%s: dhd_slpauto = %d\n", __FUNCTION__, dhd_slpauto);
 		}
 #endif
 
@@ -1860,10 +1869,10 @@
 			printf("%s: dhd_master_mode = %d\n", __FUNCTION__, dhd_master_mode);
 		}
 
-#ifdef PKT_FILTER_SUPPORT
-		/* Process pkt_filter_add:
-		 * All pkt: pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
-		 */
+#ifdef PKT_FILTER_SUPPORT
+		/* Process pkt_filter_add:
+		 * All pkt: pkt_filter_add=99 0 0 0 0x000000000000 0x000000000000
+		 */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "pkt_filter_add=");
 		pick_tmp = pick;
@@ -1897,7 +1906,7 @@
 				printf("%d ", conf->pkt_filter_del.id[i]);
 			printf("\n");
 		}
-#endif
+#endif
 
 		/* Process srl parameters */
 		memset(pick, 0, MAXSZ_BUF);
@@ -1919,7 +1928,7 @@
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "bcn_timeout=");
 		if (len_val) {
-			conf->bcn_timeout= (uint)simple_strtol(pick, NULL, 10);
+			conf->bcn_timeout= (uint)simple_strtol(pick, NULL, 10);
 			printf("%s: bcn_timeout = %d\n", __FUNCTION__, conf->bcn_timeout);
 		}
 
@@ -1939,7 +1948,7 @@
 			printf("%s: ampdu_ba_wsize = %d\n", __FUNCTION__, conf->ampdu_ba_wsize);
 		}
 
-		/* Process kso_enable parameters */
+		/* Process kso_enable parameters */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "kso_enable=");
 		if (len_val) {
@@ -1995,23 +2004,23 @@
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "txglomsize=");
 		if (len_val) {
-			conf->txglomsize = (uint)simple_strtol(pick, NULL, 10);
-			if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
-				conf->txglomsize = SDPCM_MAXGLOM_SIZE;
+			conf->txglomsize = (uint)simple_strtol(pick, NULL, 10);
+			if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
+				conf->txglomsize = SDPCM_MAXGLOM_SIZE;
 			printf("%s: txglomsize = %d\n", __FUNCTION__, conf->txglomsize);
 		}
-
-		/* Process swtxglom parameters */
+
+		/* Process swtxglom parameters */
 		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "swtxglom=");
+		len_val = process_config_vars(bufp, len, pick, "swtxglom=");
 		if (len_val) {
 			if (!strncmp(pick, "0", len_val))
-				conf->swtxglom = FALSE;
+				conf->swtxglom = FALSE;
 			else
-				conf->swtxglom = TRUE;
-			printf("%s: swtxglom = %d\n", __FUNCTION__, conf->swtxglom);
-		}
-
+				conf->swtxglom = TRUE;
+			printf("%s: swtxglom = %d\n", __FUNCTION__, conf->swtxglom);
+		}
+
 		/* Process txglom_ext parameters */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "txglom_ext=");
@@ -2025,12 +2034,12 @@
 				if ((conf->chip == BCM43362_CHIP_ID) || (conf->chip == BCM4330_CHIP_ID))
 					conf->txglom_bucket_size = 1680;
 				else if (conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-						conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID)
+						conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID)
 					conf->txglom_bucket_size = 1684;
 			}
 			printf("%s: txglom_bucket_size = %d\n", __FUNCTION__, conf->txglom_bucket_size);
 		}
-#endif
+#endif
 
 		/* Process disable_proptx parameters */
 		memset(pick, 0, MAXSZ_BUF);
@@ -2078,39 +2087,39 @@
 			printf("%s: PM = %d\n", __FUNCTION__, conf->pm);
 		}
 
-		/* Process tcpack_sup_mode parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "tcpack_sup_mode=");
-		if (len_val) {
-			conf->tcpack_sup_mode = (uint)simple_strtol(pick, NULL, 10);
-			printf("%s: tcpack_sup_mode = %d\n", __FUNCTION__, conf->tcpack_sup_mode);
-		}
-
-		/* Process dhd_poll parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "dhd_poll=");
-		if (len_val) {
-			if (!strncmp(pick, "0", len_val))
-				conf->dhd_poll = 0;
-			else
-				conf->dhd_poll = 1;
-			printf("%s: dhd_poll = %d\n", __FUNCTION__, conf->dhd_poll);
-		}
-
-		/* Process deferred_tx_len parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "deferred_tx_len=");
-		if (len_val) {
-			conf->deferred_tx_len = (int)simple_strtol(pick, NULL, 10);
-			printf("%s: deferred_tx_len = %d\n", __FUNCTION__, conf->deferred_tx_len);
-		}
-
-		/* Process pktprio8021x parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "pktprio8021x=");
-		if (len_val) {
-			conf->pktprio8021x = (int)simple_strtol(pick, NULL, 10);
-			printf("%s: pktprio8021x = %d\n", __FUNCTION__, conf->pktprio8021x);
+		/* Process tcpack_sup_mode parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "tcpack_sup_mode=");
+		if (len_val) {
+			conf->tcpack_sup_mode = (uint)simple_strtol(pick, NULL, 10);
+			printf("%s: tcpack_sup_mode = %d\n", __FUNCTION__, conf->tcpack_sup_mode);
+		}
+
+		/* Process dhd_poll parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "dhd_poll=");
+		if (len_val) {
+			if (!strncmp(pick, "0", len_val))
+				conf->dhd_poll = 0;
+			else
+				conf->dhd_poll = 1;
+			printf("%s: dhd_poll = %d\n", __FUNCTION__, conf->dhd_poll);
+		}
+
+		/* Process deferred_tx_len parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "deferred_tx_len=");
+		if (len_val) {
+			conf->deferred_tx_len = (int)simple_strtol(pick, NULL, 10);
+			printf("%s: deferred_tx_len = %d\n", __FUNCTION__, conf->deferred_tx_len);
+		}
+
+		/* Process pktprio8021x parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "pktprio8021x=");
+		if (len_val) {
+			conf->pktprio8021x = (int)simple_strtol(pick, NULL, 10);
+			printf("%s: pktprio8021x = %d\n", __FUNCTION__, conf->pktprio8021x);
 		}
 
 		/* Process txctl_tmo_fix parameters */
@@ -2122,8 +2131,8 @@
 			else
 				conf->txctl_tmo_fix = TRUE;
 			printf("%s: txctl_tmo_fix = %d\n", __FUNCTION__, conf->txctl_tmo_fix);
-		}
-
+		}
+
 		/* Process tx_in_rx parameters */
 		memset(pick, 0, MAXSZ_BUF);
 		len_val = process_config_vars(bufp, len, pick, "tx_in_rx=");
@@ -2149,46 +2158,46 @@
 		if (len_val) {
 			dhd_rxbound = (uint)simple_strtol(pick, NULL, 10);
 			printf("%s: dhd_rxbound = %d\n", __FUNCTION__, dhd_rxbound);
-		}
-
-		/* Process tx_max_offset parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "tx_max_offset=");
-		if (len_val) {
-			conf->tx_max_offset = (int)simple_strtol(pick, NULL, 10);
-			printf("%s: tx_max_offset = %d\n", __FUNCTION__, conf->tx_max_offset);
-		}
-
-		/* Process rsdb_mode parameters */
-		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "rsdb_mode=");
-		if (len_val) {
-			conf->rsdb_mode = (int)simple_strtol(pick, NULL, 10);
-			printf("%s: rsdb_mode = %d\n", __FUNCTION__, conf->rsdb_mode);
-		}
+		}
+
+		/* Process tx_max_offset parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "tx_max_offset=");
+		if (len_val) {
+			conf->tx_max_offset = (int)simple_strtol(pick, NULL, 10);
+			printf("%s: tx_max_offset = %d\n", __FUNCTION__, conf->tx_max_offset);
+		}
+
+		/* Process rsdb_mode parameters */
+		memset(pick, 0, MAXSZ_BUF);
+		len_val = process_config_vars(bufp, len, pick, "rsdb_mode=");
+		if (len_val) {
+			conf->rsdb_mode = (int)simple_strtol(pick, NULL, 10);
+			printf("%s: rsdb_mode = %d\n", __FUNCTION__, conf->rsdb_mode);
+		}
 
-		/* Process txglom_mode parameters */
+		/* Process txglom_mode parameters */
 		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "txglom_mode=");
+		len_val = process_config_vars(bufp, len, pick, "txglom_mode=");
 		if (len_val) {
 			if (!strncmp(pick, "0", len_val))
-				conf->txglom_mode = FALSE;
+				conf->txglom_mode = FALSE;
 			else
-				conf->txglom_mode = TRUE;
-			printf("%s: txglom_mode = %d\n", __FUNCTION__, conf->txglom_mode);
-		}
-
-		/* Process vhtmode parameters */
+				conf->txglom_mode = TRUE;
+			printf("%s: txglom_mode = %d\n", __FUNCTION__, conf->txglom_mode);
+		}
+
+		/* Process vhtmode parameters */
 		memset(pick, 0, MAXSZ_BUF);
-		len_val = process_config_vars(bufp, len, pick, "vhtmode=");
+		len_val = process_config_vars(bufp, len, pick, "vhtmode=");
 		if (len_val) {
 			if (!strncmp(pick, "0", len_val))
-				conf->vhtmode = 0;
+				conf->vhtmode = 0;
 			else
-				conf->vhtmode = 1;
-			printf("%s: vhtmode = %d\n", __FUNCTION__, conf->vhtmode);
-		}
-
+				conf->vhtmode = 1;
+			printf("%s: vhtmode = %d\n", __FUNCTION__, conf->vhtmode);
+		}
+
 		bcmerror = 0;
 	} else {
 		CONFIG_ERROR(("%s: error reading config file: %d\n", __FUNCTION__, len));
@@ -2196,9 +2205,9 @@
 	}
 
 err:
-	if (pick)
-		MFREE(dhd->osh, pick, MAXSZ_BUF);
-
+	if (pick)
+		MFREE(dhd->osh, pick, MAXSZ_BUF);
+
 	if (memblock)
 		MFREE(dhd->osh, memblock, MAXSZ_CONFIG);
 
@@ -2237,44 +2246,44 @@
 	return 0;
 }
 
-void
-dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable)
-{
-	struct dhd_conf *conf = dhd->conf;
-
-	if (enable) {
-#if defined(SWTXGLOM)
-		if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
-				conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-				conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-			// 43362/4330/4334/43340/43341/43241 must use 1.88.45.x swtxglom if txglom_ext is true, since 1.201.59 not support swtxglom
-			conf->swtxglom = TRUE;
-			conf->txglom_ext = TRUE;
-		}
-		if (conf->chip == BCM43362_CHIP_ID && conf->bus_txglom == 0) {
-			conf->bus_txglom = 1; // improve tcp tx tput. and cpu idle for 43362 only
-		}
-#endif
-		// other parameters set in preinit or config.txt
-	} else {
-		// clear txglom parameters, but don't change swtxglom since it's possible enabled in config.txt
-		conf->txglom_ext = FALSE;
-		conf->txglom_bucket_size = 0;
-		conf->tx_in_rx = TRUE;
-		conf->tx_max_offset = 0;
-		conf->txglomsize = 0;
-		conf->deferred_tx_len = 0;
-	}
-	printf("%s: swtxglom=%d, txglom_ext=%d\n", __FUNCTION__,
-		conf->swtxglom, conf->txglom_ext);
-	printf("%s: txglom_bucket_size=%d\n", __FUNCTION__, conf->txglom_bucket_size);
-	printf("%s: txglomsize=%d, deferred_tx_len=%d, bus_txglom=%d\n", __FUNCTION__,
-		conf->txglomsize, conf->deferred_tx_len, conf->bus_txglom);
-	printf("%s: tx_in_rx=%d, tx_max_offset=%d\n", __FUNCTION__,
-		conf->tx_in_rx, conf->tx_max_offset);
-
-}
-
+void
+dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable)
+{
+	struct dhd_conf *conf = dhd->conf;
+
+	if (enable) {
+#if defined(SWTXGLOM)
+		if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
+				conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+				conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+			// 43362/4330/4334/43340/43341/43241 must use 1.88.45.x swtxglom if txglom_ext is true, since 1.201.59 not support swtxglom
+			conf->swtxglom = TRUE;
+			conf->txglom_ext = TRUE;
+		}
+		if (conf->chip == BCM43362_CHIP_ID && conf->bus_txglom == 0) {
+			conf->bus_txglom = 1; // improve tcp tx tput. and cpu idle for 43362 only
+		}
+#endif
+		// other parameters set in preinit or config.txt
+	} else {
+		// clear txglom parameters, but don't change swtxglom since it's possible enabled in config.txt
+		conf->txglom_ext = FALSE;
+		conf->txglom_bucket_size = 0;
+		conf->tx_in_rx = TRUE;
+		conf->tx_max_offset = 0;
+		conf->txglomsize = 0;
+		conf->deferred_tx_len = 0;
+	}
+	printf("%s: swtxglom=%d, txglom_ext=%d\n", __FUNCTION__,
+		conf->swtxglom, conf->txglom_ext);
+	printf("%s: txglom_bucket_size=%d\n", __FUNCTION__, conf->txglom_bucket_size);
+	printf("%s: txglomsize=%d, deferred_tx_len=%d, bus_txglom=%d\n", __FUNCTION__,
+		conf->txglomsize, conf->deferred_tx_len, conf->bus_txglom);
+	printf("%s: tx_in_rx=%d, tx_max_offset=%d\n", __FUNCTION__,
+		conf->tx_in_rx, conf->tx_max_offset);
+
+}
+
 int
 dhd_conf_preinit(dhd_pub_t *dhd)
 {
@@ -2287,7 +2296,7 @@
 	dhd_conf_free_mac_list(&conf->nv_by_mac);
 	dhd_conf_free_chip_nv_path_list(&conf->nv_by_chip);
 #endif
-	memset(&conf->country_list, 0, sizeof(conf_country_list_t));
+	memset(&conf->country_list, 0, sizeof(conf_country_list_t));
 	conf->band = WLC_BAND_AUTO;
 	conf->mimo_bw_cap = -1;
 	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
@@ -2295,9 +2304,9 @@
 		strcpy(conf->cspec.ccode, "ALL");
 		conf->cspec.rev = 0;
 	} else if (conf->chip == BCM4335_CHIP_ID || conf->chip == BCM4339_CHIP_ID ||
-			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
-			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
-			conf->chip == BCM4359_CHIP_ID) {
+			conf->chip == BCM4354_CHIP_ID || conf->chip == BCM4356_CHIP_ID ||
+			conf->chip == BCM4345_CHIP_ID || conf->chip == BCM4371_CHIP_ID ||
+			conf->chip == BCM4359_CHIP_ID) {
 		strcpy(conf->cspec.country_abbrev, "CN");
 		strcpy(conf->cspec.ccode, "CN");
 		conf->cspec.rev = 38;
@@ -2339,7 +2348,7 @@
 #ifdef PKT_FILTER_SUPPORT
 	memset(&conf->pkt_filter_add, 0, sizeof(conf_pkt_filter_add_t));
 	memset(&conf->pkt_filter_del, 0, sizeof(conf_pkt_filter_del_t));
-	conf->pkt_filter_magic = FALSE;
+	conf->pkt_filter_magic = FALSE;
 #endif
 	conf->srl = -1;
 	conf->lrl = -1;
@@ -2350,31 +2359,31 @@
 	conf->lpc = -1;
 	conf->disable_proptx = 0;
 	conf->bus_txglom = 0;
-	conf->use_rxchain = 0;
+	conf->use_rxchain = 0;
 	conf->bus_rxglom = TRUE;
-	conf->txglom_ext = FALSE;
-	conf->tx_max_offset = 0;
-	conf->deferred_tx_len = 0;
-	conf->txglomsize = SDPCM_DEFGLOM_SIZE;
+	conf->txglom_ext = FALSE;
+	conf->tx_max_offset = 0;
+	conf->deferred_tx_len = 0;
+	conf->txglomsize = SDPCM_DEFGLOM_SIZE;
 	conf->ampdu_ba_wsize = 0;
 	conf->dpc_cpucore = 0;
 	conf->frameburst = -1;
 	conf->deepsleep = FALSE;
 	conf->pm = -1;
-#ifdef DHDTCPACK_SUPPRESS
-	conf->tcpack_sup_mode = TCPACK_SUP_OFF;
-#endif
-	conf->dhd_poll = -1;
+#ifdef DHDTCPACK_SUPPRESS
+	conf->tcpack_sup_mode = TCPACK_SUP_OFF;
+#endif
+	conf->dhd_poll = -1;
 	conf->pktprio8021x = -1;
-	conf->txctl_tmo_fix = FALSE;
-	conf->tx_in_rx = TRUE;
-	conf->rsdb_mode = -2;
-	conf->txglom_mode = SDPCM_TXGLOM_MDESC;
-	conf->vhtmode = -1;
+	conf->txctl_tmo_fix = FALSE;
+	conf->tx_in_rx = TRUE;
+	conf->rsdb_mode = -2;
+	conf->txglom_mode = SDPCM_TXGLOM_MDESC;
+	conf->vhtmode = -1;
 	if ((conf->chip == BCM43362_CHIP_ID) || (conf->chip == BCM4330_CHIP_ID)) {
-		conf->disable_proptx = 1;
+		conf->disable_proptx = 1;
 	}
-	if (conf->chip == BCM43430_CHIP_ID) {
+	if (conf->chip == BCM43430_CHIP_ID) {
 		conf->bus_rxglom = FALSE;
 	}
 	if (conf->chip == BCM4339_CHIP_ID) {
@@ -2389,78 +2398,78 @@
 	if (conf->chip == BCM4356_CHIP_ID) {
 		conf->txbf = 1;
 	}
-	if (conf->chip == BCM4371_CHIP_ID) {
-		conf->txbf = 1;
-	}
-	if (conf->chip == BCM4359_CHIP_ID) {
-		conf->txbf = 1;
-		conf->rsdb_mode = 0;
-	}
-
-#if defined(SWTXGLOM)
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
-			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		conf->swtxglom = FALSE; // disabled by default
-		conf->txglom_ext = TRUE; // enabled by default
-		conf->use_rxchain = 0; // use_rxchain have been disabled if swtxglom enabled
-		conf->txglomsize = 16;
-	} else {
-		conf->swtxglom = FALSE; // use 1.201.59.x txglom by default
-		conf->txglom_ext = FALSE;
-	}
-
-	if (conf->chip == BCM43362_CHIP_ID) {
-		conf->txglom_bucket_size = 1680; // fixed value, don't change
-		conf->tx_in_rx = FALSE;
-		conf->tx_max_offset = 1;
-	}
-	if (conf->chip == BCM4330_CHIP_ID) {
-		conf->txglom_bucket_size = 1680; // fixed value, don't change
-		conf->tx_in_rx = FALSE;
-		conf->tx_max_offset = 0;
-	}
-	if (conf->chip == BCM4334_CHIP_ID) {
-		conf->txglom_bucket_size = 1684; // fixed value, don't change
-		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
-		conf->tx_max_offset = 0; // reduce udp tx: dhdsdio_readframes: got unlikely tx max 109 with tx_seq 110
-	}
-	if (conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID) {
-		conf->txglom_bucket_size = 1684; // fixed value, don't change
-		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
-		conf->tx_max_offset = 1;
-	}
-	if (conf->chip == BCM4324_CHIP_ID) {
-		conf->txglom_bucket_size = 1684; // fixed value, don't change
-		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
-		conf->tx_max_offset = 0;
-	}
-#endif
-#if defined(BCMSDIOH_TXGLOM_EXT)
-	conf->txglom_mode = SDPCM_TXGLOM_CPY;
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
-			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
-			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		conf->txglom_ext = TRUE;
-		conf->use_rxchain = 0;
-		conf->tx_in_rx = TRUE;
-		conf->tx_max_offset = 1;
-	} else {
-		conf->txglom_ext = FALSE;
-	}
-	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
-		conf->txglom_bucket_size = 1680; // fixed value, don't change
-		conf->txglomsize = 6;
-	}
-	if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
-			conf->chip == BCM43341_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
-		conf->txglom_bucket_size = 1684; // fixed value, don't change
-		conf->txglomsize = 16;
-	}
-#endif
-	if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
-		conf->txglomsize = SDPCM_MAXGLOM_SIZE;
-	conf->deferred_tx_len = conf->txglomsize;
+	if (conf->chip == BCM4371_CHIP_ID) {
+		conf->txbf = 1;
+	}
+	if (conf->chip == BCM4359_CHIP_ID) {
+		conf->txbf = 1;
+		conf->rsdb_mode = 0;
+	}
+
+#if defined(SWTXGLOM)
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
+			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		conf->swtxglom = FALSE; // disabled by default
+		conf->txglom_ext = TRUE; // enabled by default
+		conf->use_rxchain = 0; // use_rxchain have been disabled if swtxglom enabled
+		conf->txglomsize = 16;
+	} else {
+		conf->swtxglom = FALSE; // use 1.201.59.x txglom by default
+		conf->txglom_ext = FALSE;
+	}
+
+	if (conf->chip == BCM43362_CHIP_ID) {
+		conf->txglom_bucket_size = 1680; // fixed value, don't change
+		conf->tx_in_rx = FALSE;
+		conf->tx_max_offset = 1;
+	}
+	if (conf->chip == BCM4330_CHIP_ID) {
+		conf->txglom_bucket_size = 1680; // fixed value, don't change
+		conf->tx_in_rx = FALSE;
+		conf->tx_max_offset = 0;
+	}
+	if (conf->chip == BCM4334_CHIP_ID) {
+		conf->txglom_bucket_size = 1684; // fixed value, don't change
+		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
+		conf->tx_max_offset = 0; // reduce udp tx: dhdsdio_readframes: got unlikely tx max 109 with tx_seq 110
+	}
+	if (conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID) {
+		conf->txglom_bucket_size = 1684; // fixed value, don't change
+		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
+		conf->tx_max_offset = 1;
+	}
+	if (conf->chip == BCM4324_CHIP_ID) {
+		conf->txglom_bucket_size = 1684; // fixed value, don't change
+		conf->tx_in_rx = TRUE; // improve tcp tx tput. and cpu idle
+		conf->tx_max_offset = 0;
+	}
+#endif
+#if defined(BCMSDIOH_TXGLOM_EXT)
+	conf->txglom_mode = SDPCM_TXGLOM_CPY;
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID ||
+			conf->chip == BCM43340_CHIP_ID || conf->chip == BCM43341_CHIP_ID ||
+			conf->chip == BCM4334_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		conf->txglom_ext = TRUE;
+		conf->use_rxchain = 0;
+		conf->tx_in_rx = TRUE;
+		conf->tx_max_offset = 1;
+	} else {
+		conf->txglom_ext = FALSE;
+	}
+	if (conf->chip == BCM43362_CHIP_ID || conf->chip == BCM4330_CHIP_ID) {
+		conf->txglom_bucket_size = 1680; // fixed value, don't change
+		conf->txglomsize = 6;
+	}
+	if (conf->chip == BCM4334_CHIP_ID || conf->chip == BCM43340_CHIP_ID ||
+			conf->chip == BCM43341_CHIP_ID || conf->chip == BCM4324_CHIP_ID) {
+		conf->txglom_bucket_size = 1684; // fixed value, don't change
+		conf->txglomsize = 16;
+	}
+#endif
+	if (conf->txglomsize > SDPCM_MAXGLOM_SIZE)
+		conf->txglomsize = SDPCM_MAXGLOM_SIZE;
+	conf->deferred_tx_len = conf->txglomsize;
 
 	return 0;
 }
diff -Naur brcmap6xxx-aml-de3f5c5.orig/bcmdhd_1_201_59_x/dhd_config.h brcmap6xxx-aml-de3f5c5/bcmdhd_1_201_59_x/dhd_config.h
--- brcmap6xxx-aml-de3f5c5.orig/bcmdhd_1_201_59_x/dhd_config.h	2018-11-06 21:49:41.621431878 +0100
+++ brcmap6xxx-aml-de3f5c5/bcmdhd_1_201_59_x/dhd_config.h	2018-11-06 23:02:24.000000000 +0100
@@ -1,217 +1,218 @@
-
-#ifndef _dhd_config_
-#define _dhd_config_
-
-#include <bcmdevs.h>
-#include <dngl_stats.h>
-#include <dhd.h>
-#include <wlioctl.h>
-#include <proto/802.11.h>
-
-#define FW_PATH_AUTO_SELECT 1
-//#define CONFIG_PATH_AUTO_SELECT
-extern char firmware_path[MOD_PARAM_PATHLEN];
-extern int disable_proptx;
+
+#ifndef _dhd_config_
+#define _dhd_config_
+
+#include <bcmdevs.h>
+#include <dngl_stats.h>
+#include <dhd.h>
+#include <wlioctl.h>
+#include <proto/802.11.h>
+
+#define FW_PATH_AUTO_SELECT 1
+//#define CONFIG_PATH_AUTO_SELECT
+extern char firmware_path[MOD_PARAM_PATHLEN];
+extern int disable_proptx;
 extern uint dhd_rxbound;
 extern uint dhd_txbound;
 #define TXGLOM_RECV_OFFSET 8
-#ifdef BCMSDIO
-extern uint dhd_doflow;
-extern uint dhd_slpauto;
-
-#define BCM43362A0_CHIP_REV     0
-#define BCM43362A2_CHIP_REV     1
-#define BCM43430A0_CHIP_REV     0
-#define BCM43430A1_CHIP_REV     1
-#define BCM4330B2_CHIP_REV      4
-#define BCM4334B1_CHIP_REV      3
-#define BCM43341B0_CHIP_REV     2
-#define BCM43241B4_CHIP_REV     5
-#define BCM4335A0_CHIP_REV      2
-#define BCM4339A0_CHIP_REV      1
-#define BCM43455C0_CHIP_REV     6
-#define BCM4354A1_CHIP_REV      1
-#define BCM4359B1_CHIP_REV      5
-#endif
-#define BCM4356A2_CHIP_REV      2
-
-/* mac range */
-typedef struct wl_mac_range {
-	uint32 oui;
-	uint32 nic_start;
-	uint32 nic_end;
-} wl_mac_range_t;
-
-/* mac list */
-typedef struct wl_mac_list {
-	int count;
-	wl_mac_range_t *mac;
-	char name[MOD_PARAM_PATHLEN];		/* path */
-} wl_mac_list_t;
-
-/* mac list head */
-typedef struct wl_mac_list_ctrl {
-	int count;
-	struct wl_mac_list *m_mac_list_head;
-} wl_mac_list_ctrl_t;
-
-/* chip_nv_path */
-typedef struct wl_chip_nv_path {
-	uint chip;
-	uint chiprev;
-	char name[MOD_PARAM_PATHLEN];		/* path */
-} wl_chip_nv_path_t;
-
-/* chip_nv_path list head */
-typedef struct wl_chip_nv_path_list_ctrl {
-	int count;
-	struct wl_chip_nv_path *m_chip_nv_path_head;
-} wl_chip_nv_path_list_ctrl_t;
-
-/* channel list */
-typedef struct wl_channel_list {
-	/* in - # of channels, out - # of entries */
-	uint32 count;
-	/* variable length channel list */
-	uint32 channel[WL_NUMCHANNELS];
-} wl_channel_list_t;
-
-typedef struct wmes_param {
-	int aifsn[AC_COUNT];
-	int cwmin[AC_COUNT];
-	int cwmax[AC_COUNT];
-} wme_param_t;
-
-#ifdef PKT_FILTER_SUPPORT
-#define DHD_CONF_FILTER_MAX	8
-/* filter list */
-#define PKT_FILTER_LEN 300
-typedef struct conf_pkt_filter_add {
-	/* in - # of channels, out - # of entries */
-	uint32 count;
-	/* variable length filter list */
-	char filter[DHD_CONF_FILTER_MAX][PKT_FILTER_LEN];
-} conf_pkt_filter_add_t;
-
-/* pkt_filter_del list */
-typedef struct conf_pkt_filter_del {
-	/* in - # of channels, out - # of entries */
-	uint32 count;
-	/* variable length filter list */
-	uint32 id[DHD_CONF_FILTER_MAX];
-} conf_pkt_filter_del_t;
-#endif
-
-#define CONFIG_COUNTRY_LIST_SIZE 100
-/* country list */
-typedef struct conf_country_list {
-	uint32 count;
-	wl_country_t cspec[CONFIG_COUNTRY_LIST_SIZE];
-} conf_country_list_t;
-
-typedef struct dhd_conf {
+#ifdef BCMSDIO
+extern uint dhd_doflow;
+extern uint dhd_slpauto;
+
+#define BCM43362A0_CHIP_REV     0
+#define BCM43362A2_CHIP_REV     1
+#define BCM43430A0_CHIP_REV     0
+#define BCM43430A1_CHIP_REV     1
+#define BCM4330B2_CHIP_REV      4
+#define BCM4334B1_CHIP_REV      3
+#define BCM43341B0_CHIP_REV     2
+#define BCM43241B4_CHIP_REV     5
+#define BCM4335A0_CHIP_REV      2
+#define BCM4335B0_CHIP_REV      1
+#define BCM4339A0_CHIP_REV      1
+#define BCM43455C0_CHIP_REV     6
+#define BCM4354A1_CHIP_REV      1
+#define BCM4359B1_CHIP_REV      5
+#endif
+#define BCM4356A2_CHIP_REV      2
+
+/* mac range */
+typedef struct wl_mac_range {
+	uint32 oui;
+	uint32 nic_start;
+	uint32 nic_end;
+} wl_mac_range_t;
+
+/* mac list */
+typedef struct wl_mac_list {
+	int count;
+	wl_mac_range_t *mac;
+	char name[MOD_PARAM_PATHLEN];		/* path */
+} wl_mac_list_t;
+
+/* mac list head */
+typedef struct wl_mac_list_ctrl {
+	int count;
+	struct wl_mac_list *m_mac_list_head;
+} wl_mac_list_ctrl_t;
+
+/* chip_nv_path */
+typedef struct wl_chip_nv_path {
+	uint chip;
+	uint chiprev;
+	char name[MOD_PARAM_PATHLEN];		/* path */
+} wl_chip_nv_path_t;
+
+/* chip_nv_path list head */
+typedef struct wl_chip_nv_path_list_ctrl {
+	int count;
+	struct wl_chip_nv_path *m_chip_nv_path_head;
+} wl_chip_nv_path_list_ctrl_t;
+
+/* channel list */
+typedef struct wl_channel_list {
+	/* in - # of channels, out - # of entries */
+	uint32 count;
+	/* variable length channel list */
+	uint32 channel[WL_NUMCHANNELS];
+} wl_channel_list_t;
+
+typedef struct wmes_param {
+	int aifsn[AC_COUNT];
+	int cwmin[AC_COUNT];
+	int cwmax[AC_COUNT];
+} wme_param_t;
+
+#ifdef PKT_FILTER_SUPPORT
+#define DHD_CONF_FILTER_MAX	8
+/* filter list */
+#define PKT_FILTER_LEN 300
+typedef struct conf_pkt_filter_add {
+	/* in - # of channels, out - # of entries */
+	uint32 count;
+	/* variable length filter list */
+	char filter[DHD_CONF_FILTER_MAX][PKT_FILTER_LEN];
+} conf_pkt_filter_add_t;
+
+/* pkt_filter_del list */
+typedef struct conf_pkt_filter_del {
+	/* in - # of channels, out - # of entries */
+	uint32 count;
+	/* variable length filter list */
+	uint32 id[DHD_CONF_FILTER_MAX];
+} conf_pkt_filter_del_t;
+#endif
+
+#define CONFIG_COUNTRY_LIST_SIZE 100
+/* country list */
+typedef struct conf_country_list {
+	uint32 count;
+	wl_country_t cspec[CONFIG_COUNTRY_LIST_SIZE];
+} conf_country_list_t;
+
+typedef struct dhd_conf {
 	uint	chip;			/* chip number */
-	uint	chiprev;		/* chip revision */
-	wl_mac_list_ctrl_t fw_by_mac;	/* Firmware auto selection by MAC */
-	wl_mac_list_ctrl_t nv_by_mac;	/* NVRAM auto selection by MAC */
-	wl_chip_nv_path_list_ctrl_t nv_by_chip;	/* NVRAM auto selection by chip */
-	conf_country_list_t country_list; /* Country list */
-	int band;			/* Band, b:2.4G only, otherwise for auto */
-	int mimo_bw_cap;			/* Bandwidth, 0:HT20ALL, 1: HT40ALL, 2:HT20IN2G_HT40PIN5G */
-	wl_country_t cspec;		/* Country */
-	wl_channel_list_t channels;	/* Support channels */
-	uint roam_off;		/* Roaming, 0:enable, 1:disable */
-	uint roam_off_suspend;		/* Roaming in suspend, 0:enable, 1:disable */
-	int roam_trigger[2];		/* The RSSI threshold to trigger roaming */
-	int roam_scan_period[2];	/* Roaming scan period */
-	int roam_delta[2];			/* Roaming candidate qualification delta */
-	int fullroamperiod;			/* Full Roaming period */
-	uint keep_alive_period;		/* The perioid in ms to send keep alive packet */
-	int force_wme_ac;
-	wme_param_t wme;	/* WME parameters */
-	int stbc;			/* STBC for Tx/Rx */
-	int phy_oclscdenable;		/* phy_oclscdenable */
-#ifdef PKT_FILTER_SUPPORT
-	conf_pkt_filter_add_t pkt_filter_add;		/* Packet filter add */
-	conf_pkt_filter_del_t pkt_filter_del;		/* Packet filter add */
-	bool pkt_filter_magic;
-#endif
-	int srl;	/* short retry limit */
-	int lrl;	/* long retry limit */
-	uint bcn_timeout;	/* beacon timeout */
-	bool kso_enable;
-	int spect;
-	int txbf;
-	int lpc;
-	int disable_proptx;
-	int bus_txglom;	/* bus:txglom */
-	int use_rxchain;
-	bool bus_rxglom;	/* bus:rxglom */
-	uint txglomsize;
-	int ampdu_ba_wsize;
-	int dpc_cpucore;
-	int frameburst;
-	bool deepsleep;
-	int pm;
-	uint8 tcpack_sup_mode;
-	int dhd_poll;
-	uint deferred_tx_len;
+	uint	chiprev;		/* chip revision */
+	wl_mac_list_ctrl_t fw_by_mac;	/* Firmware auto selection by MAC */
+	wl_mac_list_ctrl_t nv_by_mac;	/* NVRAM auto selection by MAC */
+	wl_chip_nv_path_list_ctrl_t nv_by_chip;	/* NVRAM auto selection by chip */
+	conf_country_list_t country_list; /* Country list */
+	int band;			/* Band, b:2.4G only, otherwise for auto */
+	int mimo_bw_cap;			/* Bandwidth, 0:HT20ALL, 1: HT40ALL, 2:HT20IN2G_HT40PIN5G */
+	wl_country_t cspec;		/* Country */
+	wl_channel_list_t channels;	/* Support channels */
+	uint roam_off;		/* Roaming, 0:enable, 1:disable */
+	uint roam_off_suspend;		/* Roaming in suspend, 0:enable, 1:disable */
+	int roam_trigger[2];		/* The RSSI threshold to trigger roaming */
+	int roam_scan_period[2];	/* Roaming scan period */
+	int roam_delta[2];			/* Roaming candidate qualification delta */
+	int fullroamperiod;			/* Full Roaming period */
+	uint keep_alive_period;		/* The perioid in ms to send keep alive packet */
+	int force_wme_ac;
+	wme_param_t wme;	/* WME parameters */
+	int stbc;			/* STBC for Tx/Rx */
+	int phy_oclscdenable;		/* phy_oclscdenable */
+#ifdef PKT_FILTER_SUPPORT
+	conf_pkt_filter_add_t pkt_filter_add;		/* Packet filter add */
+	conf_pkt_filter_del_t pkt_filter_del;		/* Packet filter add */
+	bool pkt_filter_magic;
+#endif
+	int srl;	/* short retry limit */
+	int lrl;	/* long retry limit */
+	uint bcn_timeout;	/* beacon timeout */
+	bool kso_enable;
+	int spect;
+	int txbf;
+	int lpc;
+	int disable_proptx;
+	int bus_txglom;	/* bus:txglom */
+	int use_rxchain;
+	bool bus_rxglom;	/* bus:rxglom */
+	uint txglomsize;
+	int ampdu_ba_wsize;
+	int dpc_cpucore;
+	int frameburst;
+	bool deepsleep;
+	int pm;
+	uint8 tcpack_sup_mode;
+	int dhd_poll;
+	uint deferred_tx_len;
 	int pktprio8021x;
-	bool txctl_tmo_fix;
-	bool swtxglom; /* SW TXGLOM */
+	bool txctl_tmo_fix;
+	bool swtxglom; /* SW TXGLOM */
 	bool txglom_ext; /* Only for 43362/4330/43340/43341/43241 */
 	/*txglom_bucket_size:
 	 * 43362/4330: 1680
 	 * 43340/43341/43241: 1684
 	 */
-	int txglom_bucket_size;
-	int tx_max_offset;
-	bool tx_in_rx; // Skip tx before rx, in order to get more glomed in tx
-	int rsdb_mode;
-	bool txglom_mode;
-	int vhtmode;
-} dhd_conf_t;
-
-#ifdef BCMSDIO
-int dhd_conf_get_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, uint8 *mac);
-void dhd_conf_set_fw_name_by_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, char *fw_path);
-void dhd_conf_set_nv_name_by_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, char *nv_path);
-#if defined(HW_OOB) || defined(FORCE_WOWLAN)
-void dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip);
-#endif
-#endif
-void dhd_conf_set_fw_name_by_chip(dhd_pub_t *dhd, char *fw_path);
-void dhd_conf_set_nv_name_by_chip(dhd_pub_t *dhd, char *nv_path);
-void dhd_conf_set_conf_path_by_nv_path(dhd_pub_t *dhd, char *conf_path, char *nv_path);
-#ifdef CONFIG_PATH_AUTO_SELECT
-void dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path);
-#endif
-int dhd_conf_set_fw_int_cmd(dhd_pub_t *dhd, char *name, uint cmd, int val, int def, bool down);
-int dhd_conf_set_fw_string_cmd(dhd_pub_t *dhd, char *cmd, int val, int def, bool down);
-uint dhd_conf_get_band(dhd_pub_t *dhd);
-int dhd_conf_set_country(dhd_pub_t *dhd);
-int dhd_conf_get_country(dhd_pub_t *dhd, wl_country_t *cspec);
-int dhd_conf_get_country_from_config(dhd_pub_t *dhd, wl_country_t *cspec);
-int dhd_conf_fix_country(dhd_pub_t *dhd);
-bool dhd_conf_match_channel(dhd_pub_t *dhd, uint32 channel);
-int dhd_conf_set_roam(dhd_pub_t *dhd);
-void dhd_conf_get_wme(dhd_pub_t *dhd, edcf_acparam_t *acp);
-void dhd_conf_set_wme(dhd_pub_t *dhd);
-void dhd_conf_add_pkt_filter(dhd_pub_t *dhd);
-bool dhd_conf_del_pkt_filter(dhd_pub_t *dhd, uint32 id);
-void dhd_conf_discard_pkt_filter(dhd_pub_t *dhd);
-void dhd_conf_set_disable_proptx(dhd_pub_t *dhd);
-int dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path);
-int dhd_conf_set_chiprev(dhd_pub_t *dhd, uint chip, uint chiprev);
-uint dhd_conf_get_chip(void *context);
-uint dhd_conf_get_chiprev(void *context);
-void dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable);
-int dhd_conf_get_pm(dhd_pub_t *dhd);
-int dhd_conf_get_tcpack_sup_mode(dhd_pub_t *dhd);
-int dhd_conf_preinit(dhd_pub_t *dhd);
-int dhd_conf_reset(dhd_pub_t *dhd);
-int dhd_conf_attach(dhd_pub_t *dhd);
-void dhd_conf_detach(dhd_pub_t *dhd);
-void *dhd_get_pub(struct net_device *dev);
-
-#endif /* _dhd_config_ */
+	int txglom_bucket_size;
+	int tx_max_offset;
+	bool tx_in_rx; // Skip tx before rx, in order to get more glomed in tx
+	int rsdb_mode;
+	bool txglom_mode;
+	int vhtmode;
+} dhd_conf_t;
+
+#ifdef BCMSDIO
+int dhd_conf_get_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, uint8 *mac);
+void dhd_conf_set_fw_name_by_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, char *fw_path);
+void dhd_conf_set_nv_name_by_mac(dhd_pub_t *dhd, bcmsdh_info_t *sdh, char *nv_path);
+#if defined(HW_OOB) || defined(FORCE_WOWLAN)
+void dhd_conf_set_hw_oob_intr(bcmsdh_info_t *sdh, uint chip);
+#endif
+#endif
+void dhd_conf_set_fw_name_by_chip(dhd_pub_t *dhd, char *fw_path);
+void dhd_conf_set_nv_name_by_chip(dhd_pub_t *dhd, char *nv_path);
+void dhd_conf_set_conf_path_by_nv_path(dhd_pub_t *dhd, char *conf_path, char *nv_path);
+#ifdef CONFIG_PATH_AUTO_SELECT
+void dhd_conf_set_conf_name_by_chip(dhd_pub_t *dhd, char *conf_path);
+#endif
+int dhd_conf_set_fw_int_cmd(dhd_pub_t *dhd, char *name, uint cmd, int val, int def, bool down);
+int dhd_conf_set_fw_string_cmd(dhd_pub_t *dhd, char *cmd, int val, int def, bool down);
+uint dhd_conf_get_band(dhd_pub_t *dhd);
+int dhd_conf_set_country(dhd_pub_t *dhd);
+int dhd_conf_get_country(dhd_pub_t *dhd, wl_country_t *cspec);
+int dhd_conf_get_country_from_config(dhd_pub_t *dhd, wl_country_t *cspec);
+int dhd_conf_fix_country(dhd_pub_t *dhd);
+bool dhd_conf_match_channel(dhd_pub_t *dhd, uint32 channel);
+int dhd_conf_set_roam(dhd_pub_t *dhd);
+void dhd_conf_get_wme(dhd_pub_t *dhd, edcf_acparam_t *acp);
+void dhd_conf_set_wme(dhd_pub_t *dhd);
+void dhd_conf_add_pkt_filter(dhd_pub_t *dhd);
+bool dhd_conf_del_pkt_filter(dhd_pub_t *dhd, uint32 id);
+void dhd_conf_discard_pkt_filter(dhd_pub_t *dhd);
+void dhd_conf_set_disable_proptx(dhd_pub_t *dhd);
+int dhd_conf_read_config(dhd_pub_t *dhd, char *conf_path);
+int dhd_conf_set_chiprev(dhd_pub_t *dhd, uint chip, uint chiprev);
+uint dhd_conf_get_chip(void *context);
+uint dhd_conf_get_chiprev(void *context);
+void dhd_conf_set_txglom_params(dhd_pub_t *dhd, bool enable);
+int dhd_conf_get_pm(dhd_pub_t *dhd);
+int dhd_conf_get_tcpack_sup_mode(dhd_pub_t *dhd);
+int dhd_conf_preinit(dhd_pub_t *dhd);
+int dhd_conf_reset(dhd_pub_t *dhd);
+int dhd_conf_attach(dhd_pub_t *dhd);
+void dhd_conf_detach(dhd_pub_t *dhd);
+void *dhd_get_pub(struct net_device *dev);
+
+#endif /* _dhd_config_ */
